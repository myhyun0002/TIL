# 2. 웹 서버의 IP 주소를 DNS 서버에 조회한다.
## 1. IP 주소의 기본
___
HTTP 리퀘스트 메시지를 만들면 **OS**에 의뢰하여 액세스 대상의 웹 서버에 송신한다.
- 브라우저는 URL 해독, HTTP 메시지를 만든다.
- 브라우저는 송신을 할 수는 없다.
- 따라서 웹 서버에게 송신하기 위해 OS에 맡긴다.
- 이 때 OS에는 URL에 있는 도메인명이 아닌 **IP주소**로 메세지 받을 웹 서버 주소를 의뢰해야 한다.

### IP 주소
#### TCP/IP
- 서브넷 : 몇 대의 pc가 허브에 연결된 것      
여러 서브넷이 모여서 하나의 라우터에 연결되면 하나의 큰 네트워크가 형성     
<br/>
여기에 주소를 할당 (OO동 OO번지)      
동 (네트워크 번호): 서브넷에 할당     
번지 (호스트 번호): 서브넷 안에 있는 pc에 할당          



이 두 주소를 합친게 IP 주소     
- IP 주소 : 네트워크 번호 + 호스트 번호   
    = 서브넷 주소 + pc 주소

액세스 대상의 **서버**까지 메세지를 운반할 때 **ip주소**로 대상 서버를 찾는다.      

> 메시지 운반 과정
> 1. 클라이언트 pc와 연결된 허브에 보내진다.
> 2. 해당 허브와 가장 가까운 라우터에 보내진다.
> 3. 라우터가 보낸 pc를 확인하고 다음 라우터에 보내도록 지시
> 4. 해당 라우터에 연결되어 있는 허브에 보낸다.
> 5. 이런 과정을 반복하여 결국 연결 서버에 보내진다.      

<br/>

> IP 주소 표기법
> - 실제 IP 주소
>     - 8자리의 10진수로 표현 2글자마다 점을 찍음
>     - ex) 10.11.12.13
>     - 원래는 32비트의 디지털 데이터
>     - 8비트씩 점을 찍음 
>       - 10진수 하나에 4비트, 8비트면 10진수 두개, 10진수 두개마다 점 찍음       

> 이런 경우 어디가 네트워크 번호고 어디가 호스트 번호인지 알 수 없음      
> 그래서 사용자가 어디가 네트워크 주소고 어디가 pc주소인지 직접 내역을 결정할 수 있다.      
> 그것을 IP주소 뒤에 붙이는 데 그걸 **넷마스크** 라고 한다.     
> ex) 10.11.12.13/255.255.255.0       
> - /를 기준으로 앞에는 IP 주소, 뒤에는 넷마스크        

> - 넷마스크에서 255 부분이 네트워크 번호
> - 넷마스크에서 0부분이 호스트 번호      
> ex) IP 주소 : 10.11.12.13 , 넷마스크 : 255.255.255.0     
> -> 네트워크 주소 : &#160; 10.11.12 , 호스트 주소 : &#160; .13
> ex) IP 주소 : 10.11.12.13 , 넷마스크 : 255.255.0.0   
> -> 네트워크 주소 : &#160; 10.11 , 호스트 주소 : &#160; .12.13


- 네트워크 표기할 때      
10.11.12.13/255.255.255.0 으로 표기하면 너무 기니까     
넷마스크 부분을 2진수로 표현했을 때 1의 개수를 오른쪽으로 표현해도 된다.
ex) 10.11.12.13/255.255.255.0 = 10.11.12.13/24
<br/>
<br/>

- 호스트 번호 비트가 모두 0인 경우      
ex) 10.11.12.0/24 = 네트워크 번호 : &#160;10.11.12, 호스트 번호 : &#160;.0      
이런 경우는 **서브넷 자체**를 의미
  - 서브넷 : 허브에 몇개의 pc가 연결된 형태
  - 즉 네트워크 자체를 의미 (하나의 그룹이라고 생각하면 됨)
<br/>
<br/>

- 호스트 번호 비트가 모두 1인 경우      
ex) 10.11.12.255/24 = 네트워크 번호 : &#160;10.11.12, 호스트 번호 : &#160;.255 = (2진수) 11111111     
이런 경우는 서브넷에 있는 기기 전체에 패킷을 보내는 **브로드캐스트** 의미
  - 브로드캐스트
    - 특정 네트워크에 속한 모든 호스트들이 듣게 되는 주소
    - 해당 네트워크 즉 해당 그룹 안에 있는 모든 pc에 패킷을 보내는 알림이
___
<br/>
<br/>

## 2. 도메인명과 IP 주소를 구분하여 사용하는 이유
___
TCP/IP의 네트워크는 IP 주소로 통신 서버를 지정하므로 IP 주소를 모르면 서버에게 메시지를 전달할 수 없다.       
이건 마치 전화번호를 모르면 전화를 못 거는 것과 같다.     
따라서 os에 메시지를 서버에 보내달라고 의뢰할 때는 반드시 IP 주소가 필요하다.
<br/>
<br/>
그러면 URL에 처음부터 IP주소를 쓰는게 좋지 않을까?      
실제로 URL에 IP주소를 넣어도 된다. 하지만 IP주소는 숫자라서 기억하기 어렵다.
전화번호부에서 우리가 전화번호를 이름으로 저장하듯이 IP주소를 도메인명으로 바꿔서 저장하면 사용자 입장에서도 기억하기 편하다. 그래서 도메인명을 사용한다.

따라서 사람은 도메인명을 사용하고 라우터는 IP 주소를 사용한다.    
도메인명을 알면 IP주소를 알 수 있고 IP주소를 알면 도메인명을 알 수 있으면 좋은데      
그 원리가 **DNS**이다.
___
<br/>
<br/>

## 3. Socket 라이브러리가 IP주소를 찾는 기능을 제공한다.
___
- IP 주소 조사하는 법   
  가장 가까운 DNS 서버에 도메인명을 알려주면서 IP주소 알려줘 라고 하면 됨   

그럼 브라우저는 어떻게 해서 DNS 서버를 조회할 수 있을까?      
DNS도 서버니 앞에서 배운 과정과 같이 클라이언트가 메시지를 보내면 DNS 서버에서 응답을 보내는 형식이다. 지금부터는 이것에 대해 알아보자.     
<br/>
<br/>

- 리졸버 : DNS 클라이언트
- 네임 리졸루션 : DNS 원리 (도메인명을 보내면 ip주소 알 수 있음) 사용하여
ip 주소를 조사하는 것
- 리졸버 : 네임 리졸루션을 실행하는 것

리졸버의 실제는 **Socket 라이브러리**에 있는 프로그램
- Socket 라이브러리란?    
  - 라이브러리 : 다양한 애플리케이션에서 이용할 수 있도록 부품화한 여러개 프로그램을 모아놓은 것 (프로그램의 부품집)
  <br/>
  <br/>
  여러개의 만든 부품을 모아서 애플리케이션 쉽게 만들 수 있음      
  어느 프로그램이나 똑같은 부품을 사용 - 표준화 가능      
<br/>

  OS 안에 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것
___
<br/>
<br/>

## 4. 리졸버를 이용하여 DNS 서버를 호출한다.
___
Socket 라이브러리에 들어있는 프로그램은 애플리케이션에서 간단히 호출하여 이용 가능    
브라우저와 같은 애플리케이션을 만들 때    
- 리졸버 프로그램명 (gethosbyname)
- 웹 서버 이름 (www.lab.cyber.co.kr)      

를 쓰기만 하면 리졸버를 호출할 수 있다.     

ex) <메모리 영역> = gethostbyname("www.lab.cyber.co.kr")

1. 위와 같이 리졸버 호출
2. DNS 서버에 조회 메시지를 보낸다.
3. DNS 서버는 도메인명에 해당하는 IP 주소를 응답 메시지에 담아 다시 보낸다.
4. 리졸버는 이것을 추출하여 IP 주소를 브라우저에서 지정한 **메모리 영역**에 저장.
5. 메모리 영역 안에 있는 IP 주소를 추출하여 HTTP 리퀘스트 메시지 + IP 주소를 OS에 보내서 송신 의뢰한다.       
___
<br/>
<br/>

## 리졸버 내부의 작동
___
애플리케이션에서 호출된 리졸버가 어떻게 작동할까?     
1. 애플리케이션 내에서 리졸버를 호출하면 애플리케이션은 잠깐 일시 중지
2. Socket 라이브러리에 있는 해당 리졸버명의 리졸버 실행
    - 이렇게 호출한 애플리케이션은 잠시 중지하고 호출받은 대상 프로그램이 실행되는 것을 **'제어권이 넘어간다'** 고 한다.
3. 리졸버에 제어권이 넘어가면 DNS 서버에 문의하기 위한 메시지 만듦
    - 이것은 웹 서버에 보내기 전에 HTTP가 리퀘스트 메시지를 만드는 것과 같다.
4. 'www.example.co.kr'의 IP 주소 알려주세요 라고 메시지를 DNS 서버에 보낸다.
5. 그러면 바로 DNS 서버로 가는 것이 아닌 OS 내부에 있는 **프로토콜 스택**을 호출하여 실행을 의뢰한다 그리고 OS에서 DNS 서버로 메시지를 보내고 응답을 받는다.
    - 리졸버도 HTTP와 같이 송 수신 기능이 없기 때문에 OS에서 DNS에 직접 
    메시지 전달하고 응답을 받는다.
    - DNS 서버에 메시지를 보낼 때도 DNS 서버의 IP 주소가 필요하다.
      - 이것은 TIP/IP의 설정 항목 중 하나로 미리 설정되어 있다. (조사할 필요 x)
6. 리졸버가 OS에 프로토콜 스택을 호출하면 제어가 리졸버에게 넘어가고 메시지 보내는 동작을 실행하여 LAN 어댑터를 통해 메시지가 DNS 서버로 송신된다.
7. 그러면 조회 메시지가 DNS 서버에 도착
8. 메시지에 있는 조회 내용을 조사하여 답을 찾는다.
  - 조사 방법도 따로 있는데 나중에 하자.
9. 해당 도메인명의 IP주소를 응답 메시지에 담아서 클라이언트에게 반송
10. 네트워크를 통해 클라이언트 측에 도착하고, 프로토콜 스택을 경유하여 리졸버에게 건네진다.
